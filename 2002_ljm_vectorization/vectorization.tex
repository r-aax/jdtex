\documentclass[
11pt,%
tightenlines,%
twoside,%
onecolumn,%
nofloats,%
nobibnotes,%
nofootinbib,%
superscriptaddress,%
noshowpacs,%
centertags]%
{revtex4}
\usepackage{ljm}
\usepackage{listings}
%\usepackage{mathacent}

\lstset{
language=C++,
basewidth=0.5em,
xleftmargin=45pt,
xrightmargin=45pt,
basicstyle=\small\ttfamily,
keywordstyle=\bfseries\underbar,
numbers=left,
numberstyle=\tiny,
stepnumber=1,
numbersep=10pt,
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=trBL,
tabsize=2,
captionpos=t,
breaklines=true,
breakatwhitespace=false,
escapeinside={\%*}{*)}
}

\begin{document}

\titlerunning{Flat Loops Vectorization}
\authorrunning{A.~A.~Rybakov and S.~S.~Shumilin}

\title{Vectorization of Flat Loops of Arbitrary Structure\\Using Instructions AVX-512}

\author{\firstname{A.~A.}~\surname{Rybakov}}
\email[E-mail: ]{rybakov.aax@gmail.com}
\affiliation{Joint Supercomputer Center of the Russian Academy of Sciences -- branch of Scientific Research Institute of System Analysis of the Russian Academy of Sciences, Leninsky prospect 32a, Moscow, 119334, Russia}

\author{\firstname{S.~S.}~\surname{Shumilin}}
\email[E-mail: ]{shumilin@jscc.ru}
\affiliation{Joint Supercomputer Center of the Russian Academy of Sciences -- branch of Scientific Research Institute of System Analysis of the Russian Academy of Sciences, Leninsky prospect 32a, Moscow, 119334, Russia}

\firstcollaboration{(Submitted by S.~S.~Submitter)}

\received{April 01, 2020}

\begin{abstract}
Широкое применение суперкомпьютерных технологий в различных сферах жизни, а также потребность проведения высокопроизводительных расчетов позволяет говорить об актуальности задачи повышения производительности исполнения расчетных кодов на суперкомпьютерах современных архитектур.
Векторизация программного кода является низкоуровневой оптимизацией, способной при относительно локальном и компактном применении кратно повысить производительность расчетных кодов.
Современные микропроцессоры Intel обладают поддержкой уникального набора инструкций AVX-512, которые ввиду своих многочисленных особенностей позволяют векторизовать программный код практически любого вида, записанный в предикатной форме.
Набор простых ограничений при разработке программ, а также инструменты векторизации с целью задействования набора инструкций AVX-512 способны существенно ускорить результирующую программу.
В статье рассматриваются подходы к векторизации плоских циклов -- программного контекста специального вида, успешная векторизация которого позволяет достичь повышения производительности суперкомпьютерных приложений даже для такого программного кода, для оптимизации которого современные оптимизирующие компиляторы оказываются бессильны.
\end{abstract}

\subclass{68N19} % Enter 2010 Mathematics Subject Classification.

\keywords{Supercomputers, vectorization, AVX-512, flat loop, predicated execution, intrinsic function.}

\maketitle

\section{Introduction}

Имитационное моделирование с использованием суперкомпьютеров в настоящее время играет важную роль в проведении исследований в различных областях науки, промышленности, бизнеса и жизни общества.
Суперкомпьютерное моделирование позволяет выполнять анализ и многокритериальную оптимизацию процессов взаимодействия объектов окружающего мира и извлекать информацию, недоступную без использования данных средств.
При проведении высокопроизводительных вычислений рассматриваются модели, использующие расчетные сетки, состоящие из десятков и сотен миллионов отдельных узлов или ячеек.
Такие размеры сеток уже являются обыденностью, и со временем требования по точности и комплексности моделей только ужесточаются.
В таких условиях повышение производительности суперкомпьютерных расчетов является актуальной задачей.
Наряду с повышением пиковой производительности самих вычислительных систем ведутся исследования по повышению эффективности систем обмена данными между вычислительными узлами, по развитию технологий управления расчетными сетками и равномерного распределения вычислений на кластере, активно развиваются инструменты языков программирования, направленные на облегчение создания высокопроизводительного параллельного кода.

Самым низкоуровневым направлением создания высокопроизводительного параллельного исполняемого кода является векторизация вычислений, позволяющая напрямую задействовать аппаратные возможности вычислителей.
Набор инструкций AVX-512 является является передовым средством повышения производительности современных микропроцессоров Intel.
В микропроцессорах с поддержкой набора инструкций AVX-512 пиковая производительность вычислителя рассчитывается с учетом использования 512-битных векторных регистров и сдвоенных FMA операций (fused multiply-add).
Это значит, что без применения векторизации для расчетного кода при использовании вещественных операций одинарной точности даже теоретически не может быть достигнута производительность выше, чем 3,125%% от пиковой.
Ввиду этого поиск методов и решений для применения векторизации в сложном программном контексте является крайне актуальной задачей.

Несмотря на все разнообразие возможного программного контекста суперкомпьютерных приложений существуют типы программных конструкций, эффективная оптимизация которых способна существенно повысить эффективность приложения целиком.
В данной статье будет рассмотрен только один тип векторизуемого программного контекста -- плоский цикл, для которого будут предложены методы векторизации с помощью AVX-512.

\section{Плоские циклы}

В рамках данной статьи будем ограничиваться рассмотрением только вычислительных задач, работающих с вещественными числами одинарной точности.
Определим понятие плоского цикла для таких задач.
В общем случае без ограничения общности плоским циклом будем называть программную конструкцию вида, показанную в листинге~\ref{lst:flatloop}.

\begin{lstlisting}[caption={Общий вид плоского цикла.},label={lst:flatloop}]
for (int i = 0; i < WIDTH; i++)
{
    <block(i)>;
}
\end{lstlisting}

\

При этом будем придерживаться следующих соглашений.
Во-первых, будем считать, что количество итераций плоского цикла $WIDTH$ в точности равно количеству элементов в векторе.
В нашем случае мы рассматриваем 512-битные векторы и вещественные данные с одинарной точностью (каждый элемент занимает 32 бита), поэтому $WIDTH = 16$.
Данное ограничение действительно не нарушает общности, так цикл с любым количеством итераций мы всегда можем разбить на несколько циклов по $WIDTH$ итераций и, возможно на еще один цикл с меньшим числом итераций (эпилог цикла).

Во-вторых, будем считать, что внутри блока кода \texttt{<block(i)>} ведется работа с массивами типа \texttt{float}, обращение к которым возможно только в виде $x[i]$, к тому же все массивы выровнены в памяти на 512 бит.
Заметим, что может встречаться программный код, не отвечающий данным требованиям, однако в большинстве случаев оказывается более выгодно скорректировать архитектуру программы и добиться выполнения требования по выравниванию данных, чем бороться с негативными эффектами при отсутствии выравнивания (невыровненные операции доступа в память занимают существенно больше времени, чем выровненные).

В-третьих, будем считать, что внутри цикла отсутствуют межитерационные зависимости.
Требования на обращения вида $x[i]$ к массивам исключают возможность межитерационных зависимостей в цикле при обращениях к массивам, однако теоретически могут быть конфликты по доступу к другим переменным.
Например, в листинге~\ref{lst:notflatloop1} показан цикл, не являющийся плоским, так как в нем есть зависимость по доступу к переменной $s$.

\begin{lstlisting}[caption={Общий вид плоского цикла.},label={lst:notflatloop1}]
for (int i = 0; i < WIDTH; i++)
{
    s += x[i];
}
\end{lstlisting}

\

Циклы, удовлетворяющие описанным соглашениям являются крайне удобными в плане векторизации.
Отсутствие межитерационных зависимостей в таком цикле позволяет выполнять итерации цикла независимо друг от друга, в любом порядке, а значит они могут быть выполнены параллельно.
Требование на количество итераций в цикле, выровненность в памяти, а также на вид обращений к элементам массивов ($x[i]$) гарантирует, что внутри данного цикла при работе с некоторым массивом $x$ мы обращаемся только к его участку, ограниченному номерами элементов от $0$ до $WIDTH - 1$.
Таким образом, для доступа к массивам внутри плоского цикла можно использовать векторные команды чтения последовательных участков памяти.

Конечно, если тело плоского цикла ограничено только обращениями в память и простейшими арифметическими операциями, то для векторизации такого цикла достаточно оптимизирующего компилятора, который с легкостью заменит внутри цикла скалярные инструкции векторными аналогами.
Однако интерес представляют такие циклы, тела которых обладают особенностями, препятствующими автоматической векторизации.
Среди таких особенностей главные проблемы представляют сложное разветвленное управление, наличие вложенных циклов, вызовы функций внутри цикла.
Все эти проблемы для плоских циклов могут быть решены с помощью инструкций AVX-512.
Для этого требуется перевести тело цикла в предикатное представление, после чего выполнить замену скалярных предикатных операций на векторные предикатные инструкции.
Прежде чем перейти к рассмотрению конкретных подходов по векторизации плоских циклов с помощью предикатного представления тела цикла, требуется кратко описать набор инструкций AVX-512, и особенно инструкции, подходящие для векторизации плоских циклов.

\section{AVX-512 instruction set}

Набор инструкций AVX-512 является естественным расширением наборов AVX и AVX2.
Он поддержан в микропроцессорах Intel, начиная с Intel Xeon Phi Knights Landing, Intel Xeon Skylake, Intel Xeon Cascade Lake.
Инструкции AVX-512 в своей работе оперируют с векторными регистрами zmm.
Всего таких регистров 32 (zmm0 -- zmm31), и они являются расширением регистров ymm (ymm0 -- ymm31 соответственно).
Каждый 512-битный векторный регистр zmm может оперировать с целочисленными и вещественными типами данных.
Например, один регистр zmm может содержать 64 целочисленных элемента размером 8 бит (byte), 32 целочисленных элемента размером 16 бит (word), 16 целочисленных элементов размером 32 бита (double), либо 8 целочисленных элементов размером 64 бита (quadro).
Аналогично, регистр zmm может содержать 16 вещественных значений размером 32 бита (вещественные числа с одинарной точностью), либо 8 вещественных значений размером 64 бита (вещественные числа двойной точности).
Кроме того, инструкции из набора AVX-512 используют в своей работе 8 специальных масочных регистров (k0 -- k7), с помощью которых обеспечивается выборочное применение операций к отдельным элементам векторов.
    
Набор инструкций AVX-512 постоянно пополняется с выходом новых линеек микропроцессоров.
Можно выделить основные подмножества инструкций:
AVX-512 F -- Foundation -- Основные инструкции работающие с 32-битными и 64-битными данными. Сюда включаются поэлементные операции над векторами, операции с масками, слияния векторов по маске, сравнение векторов, операции перестановок элементов векторов, операции конвертации и другие.
AVX-512 CD -- Conflict Detection -- Набор операций, предназначенный для разрешения конфликтов при векторизации циклов. Основная инструкция из этого набора VPCONFLICT позволяет сравнить каждый элемент первого вектора с каждым элементом второго вектора. Данная инструкция применяется для динамической проверки диапазонов адресов на предмет конфликтов.
AVX-512 ER -- Exponential and Reciprocal -- Набор инструкций для поэлементного вычисления с повышенной точностью функций $2^x$, $1/x$, $1/\sqrt{x}$.
AVX-512 PF -- Prefetch -- Инструкции предварительной подкачки данных для операций чтения и записи по адресам с произвольными смещениями (GATHER/SCATTER).
AVX-512 VL -- Vector Length -- Расширение многих инструкций на элементы данных размера 128 и 256 бит.
AVX-512 DQ -- Doubleword and Quadword -- Содержит дополнительные инструкции для работы с элементами данных размера 32 и 64 бита.
AVX-512 BW -- Byte and Word -- Расширение набора инструкции для работы с данными размера 8 и 16 бит. 
AVX-512 VNNI -- Vector Neural Network Instructions -- Дополнительные инструкции, введенные для оптимизации алгоритмов машинного обучения.

Наиболее важной отличительной особенностью набора инструкций AVX-512 является наличие в них поддержки векторных предикатов (или масок), которые позволяют применять операцию к отдельным элементам векторов.

Опишем семантику векторных инструкций AVX-512, пригодных для векторизации плоских циклов.
Условимся обозначать маленькими латинскими буквами элементы данных, с которыми мы оперируем в процессе счета (в данном случае это вещественные элементы данных формата \texttt{float}).
Арифметические операции будем записывать в естественном виде, например $r = a + b$ означает вычисление суммы двух элементов данных.
Векторы, составленные из отдельных элементов будем записывать с помощью заглавных латинских букв.
То есть будем считать, что $A$ это вектор, состоящий из $WIDTH$ отдельных элементов $a[i]$.
Под записью $R = A + B$ будем понимать поэлементную сумму векторов $A$ и $B$ и копирование результата в вектор $R$.
Заменяя операцию сложения произвольной операцией $op$ (не обязательно операцией двух аргументов), получим запись семантики векторной поэлементной операции в виде $R = op A, B$.

Для рассмотрения семантики векторных операций, работающих с масками, нам понадобится представление векторных предикатов.
Предикаты будем обозначать латинскими буквами в галочкой наверху.
Использование предиката при выборе одного из двух аргументов будем записывать с помощью тернарного оператора.
Таким, образом в выражении $r = \check{p} \ ? \ a : b$ элемент $r$ принимает значение $a$ при истинном значении предиката $\check{p}$, в противном случае он принимает значение $b$.
В векторном аналоге данной записи $R = \check{P} \ ? \ A : B$ данная операция выполняется поэлементно для элементов векторов, находящихся в позиции $i$ ($0 \le i < WIDTH$).

После рассмотрения записи семантики векторных инструкций для векторизации плоских циклов рассмотрим основные классы пригодных для этого инструкций (примеры операций и их семантика приведены в таблице~1.

\begin{table}[!h]
\label{tbl:avx512semantic}
\setcaptionmargin{0mm}
\onelinecaptionsfalse
\captionstyle{flushleft}
\caption{AVX-512 vector single precision float instructions for flat loops vectorization and their semantic.}
\bigskip
\begin{tabular}{|c|c|}
\hline
\textit{instruction name} & \textit{instrucition semantic} \\
\hline
\parbox{10cm}{VMOVAPS, VMOVUPS, VSQRTPS, VGETEXPPS, VGETMANTPS, VRCP14PS, VREDUCEPS, VRNDSCALEPS, VRSQRT14PS, VSCALEFPS} & $\begin{matrix} R = op \ A \\ R = \check{P} \ ? \ (op \ A) : R \\ R = \check{P} \ ? \ (op \ A) : 0 \end{matrix}$ \\
\hline
\parbox{10cm}{VADDPS, VANDPS, VANDNPS, VDIVPS, VMAXPS, VMINPS, VMULPS, VORPS, VSUBPS, VRANGEPS} & $\begin{matrix} R = op \ A, B \\ R = \check{P} \ ? \ (op \ A, B) : R \\ R = \check{P} \ ? \ (op \ A, B) : 0 \end{matrix}$ \\
\hline
\parbox{10cm}{VFMADD132PS, VFMADD213PS, VFMADD231PS, VFMSUB132PS, VFMSUB213PS, VFMSUB231PS, VFNMADD132PS, VFNMADD213PS, VFNMADD231PS, VFNMSUB132PS, VFNMSUB213PS, VFNMSUB231PS} & $\begin{matrix} R = op \ R, A, B \\ R = \check{P} \ ? \ (op \ R, A, B) : R \\ R = \check{P} \ ? \ (op \ R, A, B) : 0 \end{matrix}$ \\
\hline
\parbox{10cm}{VCMPPS (all variety of compare instructions)} & $\begin{matrix} \check{P} = op \ A, B \\ \check{P} = \check{Q} \ ? \ (op \ A, B) : 0 \end{matrix}$ \\
\hline
\parbox{10cm}{VBLENDPS} & $\begin{matrix} R = \check{P} \ ? \ A : B \end{matrix}$ \\
\hline
\end{tabular}
\label{tab:avx512instructions}
\end{table}   

Первым типом рассматриваемых операций являются векторные операции с одним аргументом.
В этом случае к каждому элементу вектора применяется одна и та же операция (например, получение обратной величины или вычисление квадратного корня), после чего результаты записываются в результирующий вектор.
С помощью дополнительного предикатного аргумента можно выбрать множество обрабатываемых элементов вектора.
Если же к элементу вектора не должна быть применена рассматриваемая операция, то соответствующий элемент результирующего вектора может быть либо оставлен без изменения, либо обнулен (это регулируется отдельным флагом в инструкци).

Аналогичным образом записывается семантика арифметических векторных инструкций с двумя и тремя аргументами.
Операции с двумя аргументами это обычные операции сложения, вычитания, умножения, получения максимума из двух чисел и другие.
Арифметические операции с тремя аргументами это так называемые сдвоенные, или комбинированные FMA операции, которые позволяют за одну операцию вычислитель значение выражения $\pm a \pm b$.

Следующий большой класс операций это операции сравнения.
В таблице данный класс представлен единственной операцией VCMPPS, однако данная операция скрывает в себе все множество различных операций сравнения (VCMPEQPS, VCMPLEPS, VCMPNEPS и остальные).
Данные операции выполняют поэлементное сравнение двух векторов и записывают результаты в векторный предикат.

Последний рассматриваемый класс векторных инструкций представлен одной инструкцией VBLENDPS, которая является реализацией векторного тернарного оператора $R = \check{P} \ ? \ A : B$.

На самом деле, глядя на таблицу~1, можно заметить, что описания семантики всех приведенных в ней векторных операций являются просто плоскими циклами в явном виде.
Верно также и обратное -- если некий плоский цикл можно записать в виде семантики одной или нескольких векторных инструкций, то он может быть реализован с помощью этих инструкций.

В общем целью статьи являеются методы записи плоских циклов с использованием семантики векторных инструкций, приведенных в таблице 1.

\section{Flat loops vectorization techniques}

Flat loops vectorization techniques.

\section{Flat loops vectorization practical examples}

Flat loops vectorization practical examples.

\subsection{Riemann solver vectorization}

Riemann solver vectorization.

\subsection{Vectorization of cells classification in the implementation of the immersed boundary method}

Vectorization of cells classification in the implementation of the immersed boundary method.

\section{Conclusion}

Conclusion.

\begin{acknowledgments}
The work has been done at the JSCC RAS as part of the state assignment for the topic ... The supercomputer MVS-10P, located at the JSCC RAS, was used for calculations during the research.
\end{acknowledgments}

\begin{thebibliography}{99}

\bibitem{Rettinger}
\refitem{article}
C. Rettinger, C. Godenschwager, S. Eibl, et al., {\it ``Fully Resolved Simulations of Dune Formation in Riverbeds"}, ISC High Performance , LNCS~{\bf 10266}, 3--21 (2017).

\end{thebibliography}

\end{document}
