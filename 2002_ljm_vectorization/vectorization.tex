\documentclass[
11pt,%
tightenlines,%
twoside,%
onecolumn,%
nofloats,%
nobibnotes,%
nofootinbib,%
superscriptaddress,%
noshowpacs,%
centertags]%
{revtex4}
\usepackage{ljm}
\usepackage{listings}
%\usepackage{mathacent}

\lstset{
language=C++,
basewidth=0.5em,
xleftmargin=45pt,
xrightmargin=45pt,
basicstyle=\small\ttfamily,
keywordstyle=\bfseries\underbar,
numbers=left,
numberstyle=\tiny,
stepnumber=1,
numbersep=10pt,
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=trBL,
tabsize=2,
captionpos=t,
breaklines=true,
breakatwhitespace=false,
escapeinside={\%*}{*)}
}

\begin{document}

\titlerunning{Flat Loops Vectorization}
\authorrunning{A.~A.~Rybakov and S.~S.~Shumilin}

\title{Vectorization of Flat Loops of Arbitrary Structure\\Using Instructions AVX-512}

\author{\firstname{A.~A.}~\surname{Rybakov}}
\email[E-mail: ]{rybakov.aax@gmail.com}
\affiliation{Joint Supercomputer Center of the Russian Academy of Sciences -- branch of Scientific Research Institute of System Analysis of the Russian Academy of Sciences, Leninsky prospect 32a, Moscow, 119334, Russia}

\author{\firstname{S.~S.}~\surname{Shumilin}}
\email[E-mail: ]{shumilin@jscc.ru}
\affiliation{Joint Supercomputer Center of the Russian Academy of Sciences -- branch of Scientific Research Institute of System Analysis of the Russian Academy of Sciences, Leninsky prospect 32a, Moscow, 119334, Russia}

\firstcollaboration{(Submitted by S.~S.~Submitter)}

\received{April 01, 2020}

\begin{abstract}
Widespread application of supercomputer technologies in various spheres of life, as well as the need of high-performance calculations allows us to speak about the relevance of the problem of increasing the performance of computer codes on supercomputers of modern architectures.
Vectorization of program code is a low-level optimization that can, with a relatively local and compact application, increase the productivity of computational codes by several times.
Modern Intel microprocessors have support for a unique set of instructions AVX-512, which, due to its features, allows you to vectorize almost any kind of code written in a predicate form.
A set of simple restrictions when developing programs along with vectorization tools to enable the use of the AVX-512 instruction set can significantly speed up the resulting program.
The article discusses approaches to vectorization of flat loops - a special-purpose program context, the successful vectorization of which allows to increase the productivity of supercomputer applications even for such program code for which optimizing compilers are powerless.
\end{abstract}

\subclass{68N19} % Enter 2010 Mathematics Subject Classification.

\keywords{Supercomputers, vectorization, AVX-512, flat loop, predicated execution, intrinsic function.}

\maketitle

\section{Introduction}

Имитационное моделирование с использованием суперкомпьютеров в настоящее время играет важную роль в проведении исследований в различных областях науки, промышленности, бизнеса и жизни общества.
Суперкомпьютерное моделирование позволяет выполнять анализ и многокритериальную оптимизацию процессов взаимодействия объектов окружающего мира и извлекать информацию, недоступную без использования данных средств.
При проведении высокопроизводительных вычислений рассматриваются модели, использующие расчетные сетки, состоящие из десятков и сотен миллионов отдельных узлов или ячеек.
Такие размеры сеток уже являются обыденностью, и со временем требования по точности и комплексности моделей только ужесточаются.
В таких условиях повышение производительности суперкомпьютерных расчетов является актуальной задачей.
Наряду с повышением пиковой производительности самих вычислительных систем ведутся исследования по повышению эффективности систем обмена данными между вычислительными узлами, по развитию технологий управления расчетными сетками и равномерного распределения вычислений на кластере, активно развиваются инструменты языков программирования, направленные на облегчение создания высокопроизводительного параллельного кода.

Самым низкоуровневым направлением создания высокопроизводительного параллельного исполняемого кода является векторизация вычислений, позволяющая напрямую задействовать аппаратные возможности вычислителей.
Набор инструкций AVX-512 является является передовым средством повышения производительности современных микропроцессоров Intel.
В микропроцессорах с поддержкой набора инструкций AVX-512 пиковая производительность вычислителя рассчитывается с учетом использования 512-битных векторных регистров и сдвоенных FMA операций (fused multiply-add).
Это значит, что без применения векторизации для расчетного кода при использовании вещественных операций одинарной точности даже теоретически не может быть достигнута производительность выше, чем 3,125%% от пиковой.
Ввиду этого поиск методов и решений для применения векторизации в сложном программном контексте является крайне актуальной задачей.

Несмотря на все разнообразие возможного программного контекста суперкомпьютерных приложений существуют типы программных конструкций, эффективная оптимизация которых способна существенно повысить эффективность приложения целиком.
В данной статье будет рассмотрен только один тип векторизуемого программного контекста -- плоский цикл, для которого будут предложены методы векторизации с помощью AVX-512.

\section{Плоские циклы}

В рамках данной статьи будем ограничиваться рассмотрением только вычислительных задач, работающих с вещественными числами одинарной точности.
Определим понятие плоского цикла для таких задач.
В общем случае без ограничения общности плоским циклом будем называть программную конструкцию вида, показанную в листинге~\ref{lst:flat_loop}.

\begin{lstlisting}[caption={Общий вид плоского цикла.},label={lst:flat_loop}]
for (int w = 0; w < WIDTH; w++)
{
    <block(w)>;
}
\end{lstlisting}

\

При этом будем придерживаться следующих соглашений.
Во-первых, будем считать, что количество итераций плоского цикла $WIDTH$ в точности равно количеству элементов в векторе.
В нашем случае мы рассматриваем 512-битные векторы и вещественные данные с одинарной точностью (каждый элемент занимает 32 бита), поэтому $WIDTH = 16$.
Данное ограничение действительно не нарушает общности, так цикл с любым количеством итераций мы всегда можем разбить на несколько циклов по $WIDTH$ итераций и, возможно на еще один цикл с меньшим числом итераций (эпилог цикла).

Во-вторых, будем считать, что внутри блока кода \texttt{<block(w)>} ведется работа с массивами типа \texttt{float}, обращение к которым возможно только в виде $x[w]$, к тому же все массивы выровнены в памяти на 512 бит.
Заметим, что может встречаться программный код, не отвечающий данным требованиям, однако в большинстве случаев оказывается более выгодно скорректировать архитектуру программы и добиться выполнения требования по выравниванию данных, чем бороться с негативными эффектами при отсутствии выравнивания (невыровненные операции доступа в память занимают существенно больше времени, чем выровненные).

В-третьих, будем считать, что внутри цикла отсутствуют межитерационные зависимости.
Требования на обращения вида $x[w]$ к массивам исключают возможность межитерационных зависимостей в цикле при обращениях к массивам, однако теоретически могут быть конфликты по доступу к другим переменным.
Например, в листинге~\ref{lst:not_flat_loop} показан цикл, не являющийся плоским, так как в нем есть зависимость по доступу к переменной $s$.

\begin{lstlisting}[caption={Простейший пример неплоского цикла.},label={lst:not_flat_loop}]
for (int w = 0; w < WIDTH; w++)
{
    s += x[w];
}
\end{lstlisting}

\

Циклы, удовлетворяющие описанным соглашениям являются крайне удобными в плане векторизации.
Отсутствие межитерационных зависимостей в таком цикле позволяет выполнять итерации цикла независимо друг от друга, в любом порядке, а значит они могут быть выполнены параллельно.
Требование на количество итераций в цикле, выровненность в памяти, а также на вид обращений к элементам массивов ($x[w]$) гарантирует, что внутри данного цикла при работе с некоторым массивом $x$ мы обращаемся только к его участку, ограниченному номерами элементов от $0$ до $WIDTH - 1$.
Таким образом, для доступа к массивам внутри плоского цикла можно использовать векторные команды чтения последовательных участков памяти.

Конечно, если тело плоского цикла ограничено только обращениями в память и простейшими арифметическими операциями, то для векторизации такого цикла достаточно оптимизирующего компилятора, который с легкостью заменит внутри цикла скалярные инструкции векторными аналогами.
Однако интерес представляют такие циклы, тела которых обладают особенностями, препятствующими автоматической векторизации.
Среди таких особенностей главные проблемы представляют сложное разветвленное управление, наличие вложенных циклов, вызовы функций внутри цикла.
Все эти проблемы для плоских циклов могут быть решены с помощью инструкций AVX-512.
Для этого требуется перевести тело цикла в предикатное представление, после чего выполнить замену скалярных предикатных операций на векторные предикатные инструкции.

Так как мы условились считать, что плоский цикл всегда управляется индуктивной переменной, изменяющейся в пределах от $0$ до $WIDTH$, то в дальнейшем для анализа будем характеризовать плоский цикл только его телом.
Например, для цикла из листинга~\ref{lst:flat_loop} будем говорить, что рассматривается плоский цикл \texttt{<block(w)>}.

Прежде чем перейти к рассмотрению конкретных подходов по векторизации плоских циклов с помощью предикатного представления тела цикла, требуется кратко описать набор инструкций AVX-512, и особенно инструкции, подходящие для векторизации плоских циклов.

\section{AVX-512 instruction set}

Набор инструкций AVX-512 является естественным расширением наборов AVX и AVX2.
Он поддержан в микропроцессорах Intel, начиная с Intel Xeon Phi Knights Landing, Intel Xeon Skylake, Intel Xeon Cascade Lake.
Инструкции AVX-512 в своей работе оперируют с векторными регистрами zmm.
Всего таких регистров 32 (zmm0 -- zmm31), и они являются расширением регистров ymm (ymm0 -- ymm31 соответственно).
Каждый 512-битный векторный регистр zmm может оперировать с целочисленными и вещественными типами данных.
Например, один регистр zmm может содержать 64 целочисленных элемента размером 8 бит (byte), 32 целочисленных элемента размером 16 бит (word), 16 целочисленных элементов размером 32 бита (double), либо 8 целочисленных элементов размером 64 бита (quadro).
Аналогично, регистр zmm может содержать 16 вещественных значений размером 32 бита (вещественные числа с одинарной точностью), либо 8 вещественных значений размером 64 бита (вещественные числа двойной точности).
Кроме того, инструкции из набора AVX-512 используют в своей работе 8 специальных масочных регистров (k0 -- k7), с помощью которых обеспечивается выборочное применение операций к отдельным элементам векторов.
    
Набор инструкций AVX-512 постоянно пополняется с выходом новых линеек микропроцессоров.
Можно выделить основные подмножества инструкций:
AVX-512 F -- Foundation -- Основные инструкции работающие с 32-битными и 64-битными данными.
Сюда включаются поэлементные операции над векторами, операции с масками, слияния векторов по маске, сравнение векторов, операции перестановок элементов векторов, операции конвертации и другие.
AVX-512 CD -- Conflict Detection -- Набор операций, предназначенный для разрешения конфликтов при векторизации циклов. Основная инструкция из этого набора VPCONFLICT позволяет сравнить каждый элемент первого вектора с каждым элементом второго вектора. Данная инструкция применяется для динамической проверки диапазонов адресов на предмет конфликтов.
AVX-512 ER -- Exponential and Reciprocal -- Набор инструкций для поэлементного вычисления с повышенной точностью функций $2^x$, $1/x$, $1/\sqrt{x}$.
AVX-512 PF -- Prefetch -- Инструкции предварительной подкачки данных для операций чтения и записи по адресам с произвольными смещениями (VGATHER/VSCATTER).
AVX-512 VL -- Vector Length -- Расширение многих инструкций на элементы данных размера 128 и 256 бит.
AVX-512 DQ -- Doubleword and Quadword -- Содержит дополнительные инструкции для работы с элементами данных размера 32 и 64 бита.
AVX-512 BW -- Byte and Word -- Расширение набора инструкции для работы с данными размера 8 и 16 бит. 
AVX-512 VNNI -- Vector Neural Network Instructions -- Дополнительные инструкции, введенные для оптимизации алгоритмов машинного обучения.

Наиболее важной отличительной особенностью набора инструкций AVX-512 является наличие в них поддержки векторных предикатов (или масок), которые позволяют применять операцию к отдельным элементам векторов.

Опишем семантику векторных инструкций AVX-512, пригодных для векторизации плоских циклов.
Условимся обозначать маленькими латинскими буквами элементы данных, с которыми мы оперируем в процессе счета (в данном случае это вещественные элементы данных формата \texttt{float}).
Арифметические операции будем записывать в естественном виде, например, $r = a + b$ означает вычисление суммы двух элементов данных.
Векторы, составленные из отдельных элементов будем записывать с помощью заглавных латинских букв.
То есть будем считать, что $A$ это вектор, состоящий из $WIDTH$ отдельных элементов $A[w]$.
Под записью $R = A + B$ будем понимать поэлементную сумму векторов $A$ и $B$ и копирование результата в вектор $R$.
Заменяя операцию сложения произвольной операцией $op$ (не обязательно операцией двух аргументов), получим запись семантики векторной поэлементной операции в виде $R = op A, B$.

Для рассмотрения семантики векторных операций, работающих с масками, нам понадобится представление векторных предикатов.
Предикаты будем обозначать латинскими буквами в галочкой наверху.
Использование предиката при выборе одного из двух аргументов будем записывать с помощью тернарного оператора.
Таким, образом в выражении $r = \check{p} \ ? \ a : b$ элемент $r$ принимает значение $a$ при истинном значении предиката $\check{p}$, в противном случае он принимает значение $b$.
В векторном аналоге данной записи $R = \check{P} \ ? \ A : B$ данная операция выполняется поэлементно для элементов векторов, находящихся в позиции $w$ ($0 \le w < WIDTH$).

После рассмотрения записи семантики векторных инструкций для векторизации плоских циклов рассмотрим основные классы пригодных для этого инструкций (примеры операций и их семантика приведены в таблице~1.

\begin{table}[!h]
\label{tbl:avx512semantic}
\setcaptionmargin{0mm}
\onelinecaptionsfalse
\captionstyle{flushleft}
\caption{AVX-512 vector single precision float instructions for flat loops vectorization and their semantic.}
\bigskip
\begin{tabular}{|c|c|c|}
\hline
\textit{instructions} & \textit{using examples} & \textit{instrucition semantic} \\
\hline
\parbox{8cm}{VMOVA, VMOVU, VSQRT, VGETEXP, \\ VGETMANT, VRCP14, VREDUCE, \\ VRNDSCALE, VRSQRT14, VSCALEF}
& $\begin{matrix} R = \text{VMOVA}(A) \\ R = \text{VMOVA}(\check{P}, A) \\ R = \text{VMOVAz}(\check{P}, A) \end{matrix}$
& $\begin{matrix} R = op \ A \\ R = \check{P} \ ? \ (op \ A) : R \\ R = \check{P} \ ? \ (op \ A) : 0 \end{matrix}$ \\
\hline
\parbox{8cm}{VADD, VAND, VANDN, VDIV, \\ VMAX, VMIN, VMUL, VOR, \\ VSUB, VRANGE}
& $\begin{matrix} R = \text{VADD}(A, B) \\ R = \text{VADD}(\check{P}, A, B) \\ R = \text{VADDz}(\check{P}, A, B) \end{matrix}$ 
& $\begin{matrix} R = op \ A, B \\ R = \check{P} \ ? \ (op \ A, B) : R \\ R = \check{P} \ ? \ (op \ A, B) : 0 \end{matrix}$ \\
\hline
\parbox{8cm}{VFMADD132, VFMADD213, VFMADD231, \\ VFMSUB132, VFMSUB213, VFMSUB231, \\ VFNMADD132, VFNMADD213, VFNMADD231, \\ VFNMSUB132, VFNMSUB213, VFNMSUB231}
& $\begin{matrix} R = \text{VFMADD132}(R, A, B) \\ R = \text{VFMADD132}(\check{P}, R, A, B) \\ R = \text{VFMADD132z}(\check{P}, R, A, B) \end{matrix}$
& $\begin{matrix} R = op \ R, A, B \\ R = \check{P} \ ? \ (op \ R, A, B) : R \\ R = \check{P} \ ? \ (op \ R, A, B) : 0 \end{matrix}$ \\
\hline
\parbox{8cm}{VCMP (all variety of compare instructions)}
& $\begin{matrix} \check{P} = \text{VCMP}(A, B) \\ \check{Q} = \text{VCMP}(\check{P}, A, B) \end{matrix}$
& $\begin{matrix} \check{Q} = op \ A, B \\ \check{Q} = \check{P} \ ? \ (op \ A, B) : 0 \end{matrix}$ \\
\hline
\parbox{8cm}{VBLENDM}
& $\begin{matrix} R = VBLENDM(\check{P}, A, B) \end{matrix}$
& $\begin{matrix} R = \check{P} \ ? \ A : B \end{matrix}$ \\
\hline
\end{tabular}
\label{tab:avx512instructions}
\end{table}   

Первым типом рассматриваемых операций являются векторные операции с одним аргументом.
В этом случае к каждому элементу вектора применяется одна и та же операция (например, получение обратной величины или вычисление квадратного корня), после чего результаты записываются в результирующий вектор.
С помощью дополнительного предикатного аргумента можно выбрать множество обрабатываемых элементов вектора.
Если же к элементу вектора не должна быть применена рассматриваемая операция, то соответствующий элемент результирующего вектора может быть либо оставлен без изменения, либо обнулен (это регулируется отдельным флагом в инструкции).

Аналогичным образом записывается семантика арифметических векторных инструкций с двумя и тремя аргументами.
Операции с двумя аргументами это обычные операции сложения, вычитания, умножения, получения максимума из двух чисел и другие.
Арифметические операции с тремя аргументами это так называемые сдвоенные, или комбинированные FMA операции, которые позволяют за одну операцию вычислитель значение выражения $\pm a \cdot b \pm c$.

Следующий большой класс операций это операции сравнения.
В таблице данный класс представлен единственной операцией VCMP, однако данная операция скрывает в себе все множество различных операций сравнения (VCMPEQ, VCMPLE, VCMPNE и остальные).
Данные операции выполняют поэлементное сравнение двух векторов и записывают результаты в векторный предикат.

Последний рассматриваемый класс векторных инструкций представлен одной инструкцией VBLENDM, которая является реализацией векторного тернарного оператора $R = \check{P} \ ? \ A : B$.

На самом деле, глядя на таблицу~1, можно заметить, что описания семантики всех приведенных в ней векторных операций являются просто плоскими циклами в явном виде.
Верно также и обратное -- если некий плоский цикл можно записать в виде семантики одной или нескольких векторных инструкций, то он может быть реализован с помощью этих инструкций.

В общем целью статьи являются методы записи плоских циклов с использованием семантики векторных инструкций, приведенных в таблице~1.

\section{Flat loops vectorization techniques}

\subsection{Векторизация разветвленного управления}

Разветвленное управление в теле плоского цикла имеет место при наличии операторов передачи управления, например, \texttt{if-else}, \texttt{case}, \texttt{goto} и операторов огранизации циклов \texttt{for}, \texttt{while}, \texttt{do-while}, \texttt{break}, \texttt{continue}.
Рассмотрим простейший пример, когда тело плоского цикла состоит из одной конструкции \texttt{if-else}, как показано в листинге~\ref{lst:if_else_orig}.

\begin{lstlisting}[caption={Тело плоского цикла, состоящее из конструкции \texttt{if-else}.},label={lst:if_else_orig}]
for (int w = 0; w < WIDTH; w++)
{
    if (<cond(w)>)
    {
        <block1(w)>; // t1, p1
    }
    else
    {
        <block2(w)>; // t2, p2
    }
}
\end{lstlisting}

\

Прежде всего отметим, что в данной конструкции условие \texttt{<cond(w)>} зависит от $w$.
В противном случае при константном условии возможно расщепление цикла по условию так, чтобы получилось два отдельных плоских цикла, тела которых не содержат управление.
В дальнейшем при рассмотрении условий в теле плоского цикла, мы будем предполагать, что они не являются константными.
Итак, тело плоского цикла состоит из двух блоков \texttt{<block1(w)>} и \texttt{<block2(w)>}, один из которых выполняется в зависимости от условия \texttt{<cond(w)>}.

Каждому блоку можно сопоставить его длину, определенную как количество операций в данном блоке.
Будем называть эту характеристику временем выполнения блока (блоки из листинга~\ref{lst:if_else_orig} имеют время выполнения $t_1$ и $t_2$ соответственно).
Также каждый из этих двух блоков можно охарактеризовать вероятностью его выполнения.
Вероятность выполнения блока это отношение количества выполнений блока к общему количеству итераций плоского цикла (блоки из листинга~\ref{lst:if_else_orig} имеют вероятности выполнения $p_1$ и $p_2$ соответственно).
Тогда можно посчитать общее время выполнения одной итерации плоского цикла как $t_1 p_1 + t_2 p_2$.
Общее время выполнения плоского цикла равно $T_{orig} = W(t_1 p_1 + t_2 p_2)$, где $W$ это общее количество итераций цикла, которое обозначалось в примерах кода программы через $WIDTH$.

Для векторизации данного плоского цикла необходимо векторизовать оба блока и выполнить их под противоположными векторными предикатами \texttt{<COND>} и \texttt{~<COND>}, как это показано в листинге~\ref{lst:if_else_vec}.

\begin{lstlisting}[caption={Векторизованная конструкция \texttt{if-else}.},label={lst:if_else_vec}]
<BLOCK1> ? <COND>;
<BLOCK2> ? ~<COND>;
\end{lstlisting}

\

Если предположить, что блоки \texttt{<BLOCK1>} и \texttt{<BLOCK2>} векторизованы идеально, то есть их длина (количество векторных операций) равна длине соответствующих исходных блоков \texttt{<block1(w)>} и \texttt{<block2(w)>} (количество скалярных операций), то время работы векторизованного цикла равно $T_{vec} = t_1 + t_2$.
Ускорение от применения векторизации можно вычислить по формуле

\begin{equation}
\frac{T_{orig}}{T_{vec}} = \frac{W(t_1 p_1 + t_2 p_2)}{t_1 + t_2}
\end{equation}

При наличии только одного блока (например, при $t_2 = 0$, $p_1 = 1$) получаем ожидаемое ускорение от векторизации ровно в $W$ раз.
Если же рассмотреть два одинаковых блока ($t_1 = t_2$, $p_1 = p_2 = 1/2$), то ожидаемое ускорение от векторизации будет равно уже $W/2$.
Это связано с тем, что в векторизованном коде появятся команды, выполняющиеся под векторными предикатами, и часть элементов данных предикатов нулевые.
Таким образом, векторные инструкции по сути будут обрабатывать меньше скалярных элементов, чем позволяет их длина.
Заметим, что данные вычисления сделаны в предположении, что блоки \texttt{BLOCK1} и \texttt{BLOCK2} векторизованы идеально.
Однако, в них самих могут содержаться операторы передачи управления, что еще больше понизит эффективность векторизации.

Таким образом полное слияние всех ветвей исполнения не является эффективным способом векторизации плоских циклов.
В случае, когда одна из ветвей исполнения обладает низкой вероятностью и к тому же большой длиной, то при отсутствии побочных эффектов можно применить вынос маловероятной ветки из цикла.

\begin{lstlisting}[caption={Векторизованная конструкция \texttt{if-else} с маловероятной второй веткой.},label={lst:if_else_vec_sec_lo_prob}]
<BLOCK1> ? <COND>;

if (~<COND>)
{
    <BLOCK2> ? ~<COND>;
}
\end{lstlisting}

\

В листинге~\ref{lst:if_else_vec_sec_lo_prob} показана модификация векторизованной версии плоского цикла с конструкцией \texttt{if-else} при условии маленькой вероятности второй ветки.
Теперь выполнение маловероятной ветки происходит под условием \texttt{if (\~{}<COND>)}.
Заметим, что это не векторное условие, а обычная проверка того факта, что маска \texttt{\~{}<COND>} ненулевая, и имеет смысл выполнять векторные инструкции.
К тому же при низкой вероятности выполнения второго блока даже нет необходимости его векторизовать, это не повлияет на производительность.
В реальных приложениях такие маловероятные ветки могут обрабатывать какие-то очень редкие и изощренные ситуации, и код в данных блоках может быть гораздо сложнее, чем код, обрабатывающий штатные случаи \cite{Rybakov_Aircraft}.

Другим важным приемом векторизации разветвленных условий является использование векторных инструкций, содержащих логику, и применение тождеств на их основе.
К инструкциям, содержащим логику, можно отнести такие операции, как VBLENDM, VABS (котоая реализована через инструкцию VAND), VMIN, VMAX.
По сути все эти операции содержат скрытое управление по типу \text{if-else}.
В реальных приложениях часто встречаются участки кода, логику которых можно переписать с использованием данных операций, тем самым сократив количество различных ветвей исполнения.
Рассмотрим в качестве примера ограничение значения некоторой переменной с помощью заданной нижней и верхней границ, как это показана на листинге~\ref{lst:bounds_orig}

\begin{lstlisting}[caption={Ограничение значения величины с помощью нижней и верхней границ.},label={lst:bounds_orig}]
for (int w = 0; w < WIDTH; w++)
{
    if (x[w] < a[w])
    {
        x[w] = a[w];
    }
    else if (x[w] > b[w])
    {
        x[w] = b[w];
    }
}
\end{lstlisting}

\

Слияние такого участка кода не будет достаточно эффективным (к тому же в совокупности с остальными операциями плоского цикла).
Однако, применив простые тождества с использованием команд VMIN, VMAX, можно получить эквивалентную и более простую запись того же самого в векторном виде, как это показано в листинге~\ref{lst:bounds_vec}.

\begin{lstlisting}[caption={Векторизованная форма ограничения значения величины с помощью нижней и верхней границ.},label={lst:bounds_vec}]
X = VMAX X, A
X = VMIN X, B
\end{lstlisting}

\

Стоит заметить, что для обеспечения эквивалентности преобразования необходимо выполнение условия $a[w] \le b[w]$ для всех значений $w$.
Поэтому оптимизирующий компилятор не сможет применить данный шаблон, и он должен быть выполнен программистом вручную.
Это касается и многих других преобразований, не являющихся эквивалентными в строгом смысле, но являющихся допустимыми с точки зрения логики программы.

\subsection{Векторизация вложенных циклов}

Тело плоского цикла само по себе может содержать гнезда циклов.
Если условия выхода из этих вложенных циклов являются константными, то никаких проблем с векторизацией не возникает (в данном случае действует та же аналогия, что и в случае константных условий в разветвленном управлении).
Поэтому будем считать, что вложенный цикл у нас имеет зависящее от $w$ условие выхода.
Другими словами, количество итераций такого цикла не является константным.
Для наглядности рассмотрим простую конструкцию, подходящую под данные требования (листинг~\ref{lst:while_loop}).

\begin{lstlisting}[caption={Плоский цикл, содержащий цикл с неконстантным числом итераций},label={lst:while_loop}]
for (int w = 0; w < WIDTH; w++)
{
    while (true)
    {
        if (sqrt(x[w]) < 1.0)
        {
            x[w] -= 1.0;

            break;
        }
            
        x[w] /= 2.0;
    }
}
\end{lstlisting}

\

Основная проблема в векторизации данного фрагмента заключается в том, что при разных значениях $w$ может выполниться разное количество итераций внутреннего цикла (может даже оказаться так, что цикл бесконечный).
Для обеспечения векторизации нужно завести специальный векторный предикат, который будет сигнализировать о том, для каких $w$ требуется продолжить выполнение внутреннего цикла, а для каких его следует прервать.
Полное прекращение выполнения цикла наступит только в том случае, когда весь векторный предикат станет нулевым.
Для векторизации указанного гнезда его сначала требуется перевести в предикатную форму.
При этом важно выделить два предиката: предикат необходимости итерации и предикат выполнения условия выхода.
Особенностью приведенного фрагмента является то, что в случае выхода из цикла, мы уже не имеем права проверять условие \texttt{sqrt(x[w]) < 1.0}, то есть проверка этого условия должна происходить под предикатом выполнения итерации цикла (для скалярного кода это и так выполняется, а для векторного аналога данное требование должно быть обеспечено явно).
На листинге~\ref{lst:while_loop_pred} показано представление данного гнезда в предикатной форме. 

\begin{lstlisting}[caption={Предикатная форма плоского цикла, содержащего цикл с неконстантным числом итераций},label={lst:while_loop_pred}]
for (int w = 0; w < WIDTH; w++)
{
    bool is_iter = true;

    while (is_iter)
    {
        bool is_pos = is_iter ? (sqrt(x[w]) < 1.0) : false;
        bool is_neg = is_iter && !is_pos;    
    
        x[w] = is_pos ? (x[w] - 1.0) : x[w];
        x[w] = is_neg ? (x[w] / 2.0) : s[w];
        is_iter = is_neg;
    }
}
\end{lstlisting}

\

После приведения гнезда в предикатную форму заметим, что из внутреннего цикла исчезли все управляющие конструкции, а каждая инструкция выполняется под управлением предикатов.
Все элементы, кроме оператора \texttt{while (is\_iter)} имеют векторные аналоги.
Но для условия продолжения цикла векторный аналог и не нужен, так как векторизованный цикл должен продолжаться до тех пор, пока маска, составленная из отдельных условий \texttt{is\_iter} не нулевая.
Таким образом, имеем полностью векторизованный плоский цикл, запись которого приведена на листинге~\ref{lst:while_loop_vec}.

\begin{lstlisting}[caption={Векторная форма плоского цикла, содержащего цикл с неконстантным числом итераций},label={lst:while_loop_vec}]
IS_ITER = 0xFFFF;

while (IS_ITER != 0x0)
{
    IS_POS = VCMPz(IS_ITER, VSQRTz(IS_ITER, X), V1)
    IS_NEG = IS_ITER & ~IS_POS
    
    X = VSUB(IS_POS, X, V1)
    X = VDIV(IS_NEG, X, V2)
    IS_ITER = IS_NEG
}
\end{lstlisting}

\

На данном листинге V1 -- вектор, состоящий из значений 1.0, V2 -- вектор, состоящий из значений 2.0.

При векторизации плоского цикла, телом которого является гнездо циклов, нет ограничение на глубину гнезда.
Однако, необходимо для каждого цикла из гнезда поддерживать свой предикат, позволяющий выполнять итерацию цикла, чтобы при выполнении векторных инструкций случайно не были обработаны элементы данных, которые не обрабатывались в скалярном коде (иначе это может привести к нежелательным ситуациям, типа исключений вследствие работы с мусорными данными).
Необходимость отслеживать данные предикаты, конечно, привносит трудности при векторизации.
В некоторых архитектурах (например в архитектуре <<Эльбрус>>) для облегчения выполнения операций, результат которых может не быть востребован (и аргументы которых могут содержать некорректные данные), предусмотрен специальный спекулятивный режим исполнения, который игнорирует исключительные ситуации и помогает эффективно выполнять слияние разных веток программного кода.

\subsection{Векторизация вызовов функций под условием}

В плоских циклах могут встречаться вызовы функций.
Конечно, будем считать, что все вызываемые функции являются чистыми, то есть результат функции зависит только от ее аргументов.
Проблема возникает в том случае, когда функция должна быть вызвана не для всех итераций плоского цикла, а только для некоторых.
Рассмотрим простой пример, в котором присутствует такой вызов, он представлен на листинге \ref{lst:call_orig}.

\begin{lstlisting}[caption={Пример плоского цикла с вызовом функции под условием},label={lst:call_orig}]
for (int w = 0; w < WIDTH; w++)
{
    if (<cond(w)>)
    {
        x[w] = f(a[w]);
    }
    else
    {
        x[w] = b[w];
    }
}
\end{lstlisting}

\

В данном примере мы не можем напрямую векторизовать функцию $f()$ заменив в ней скалярный аргумент на векторный.
Проблема в том, что как и в случае векторизации гнезд циклов, необходимо отслеживать предикат, сигнализирующий о том, к каким элементам данных функция должна быть применена.
Единственный способ это сделать -- передавать данный предикат прямо внутрь вызываемой функции.
Таким образом скалярная функция $f(a)$ должна быть расширена до векторной функции $F(P, A)$ в которую кроме векторного аргумента передается также и маска.

После корректировки вызываемой функции предложенный цикл может быть легко векторизуем путем влияния двух веток исполнения с помощью VBLENDM, как это показано в листинге \ref{lst:call_vec}.

\begin{lstlisting}[caption={Векторизация плоского цикла с вызовом функции под условием},label={lst:call_vec}]
X = VBLENDM(<COND>, F(<COND>, A), B)

\end{lstlisting}

\

Заметим, что в данном примере также наблюдается некоторая избыточность в виде повторного применения векторного предиката \texttt{<COND>} (сначала в вызове функции, а затем в операции слияния).
Эта избыточность присутствует для того, чтобы избежать возникновения исключений при обработке тех элементов данных, которые не должны обрабатываться в скалярном коде.
В данном случае проблему может представлять даже не исключение в арифметической операции (например, деление на ноль), а потенциальная возможность пойти по другому пути исполнения, который отсутствовал в скалярном коде.
А это в свою очередь может привести к более тяжелым последствиям, таким как некорректная запись в память или возникновение бесконечного цикла в функции.

\section{Flat loops vectorization practical examples}

\subsection{Использование функций-интринсиков для реализации параллельного кода}

Для удобства применения инструкций из набора AVX-512 предусмотрена библиотека специальных функций интринсиков, полный список и описание данных функций доступно на сайте \cite{Intel_Intr}.

Для использования функций-интринсиков в программе нужно подключить заголовочный файл \texttt{<immintrin.h>}.

Функции-интринсики покрывают не все инструкции AVX-512, однако избавляют от необходимости вручную писать ассемблерный код и позволяют использовать встроенные типы данных для 512-битных векторов (\texttt{\_\_m512}, \texttt{\_\_m512i}, \texttt{\_\_m512d}).
Некоторые интринсики соответствуют не отдельной команде, а целой последовательности, как например для операции сложения всех элементов вектора.
Из множества интринсиков можно выделить следующие группы функций, схожие по структуре.
Функции swizzle, shuffle, permute и permutevar осуществляют перестановку элементов вектора и раскрываются в последовательность операций, в которой присутвует VSHUF и пересылка по маске.
Для большего числа операций AVX-512 реализованы соответствующие инстринсики, раскрывающиеся в одну конкретную операцию.
Среди них арифметические операции, побитовые операции, операции чтения из памяти и записи в память, операции конвертации, слияние двух векторов, нахождение обратных значений, получение минимума и максимума из двух значений, операции сравнения, операции с масками, комбинированные операции и другие.
Некоторые инстринсики, особенно предназначенные для выполнения упакованных трансцендентных операций, раскрываются просто в вызов библиотечной функции (например \texttt{\_mm512\_log\_ps}, \texttt{\_mm512\_hypot\_ps}, тригонометрические функции).

При рассмотрении векторных кодов практических задач функции-интринсики векторных команд без использования масок будем записывать в кратком сиде

\subsection{Riemann solver vectorization}

Рассматриваемая в данном разделе реализация римановского решателя находится в открытом доступе в сети Интернет в составе библиотеки NUMERICA \cite{Numerica}.
Нас в данном случае будет интересовать одномерный случай для однокомпонентной среды, реализованный в виде чистой функции (функции без побочных эффектов, результат работы функции зависит только от значений входных параметров), которая по значениям плотности, скорости и давления газа слева и справа от разрыва, находит значения этих же величин на самом разрыве в нулевой момент времени после устранения перегородки.

\begin{equation}\label{eq:riemann}
U_l = \left( \begin{array}{ccc} d_l \\ u_l \\ p_l \end{array} \right),
U_r = \left( \begin{array}{ccc} d_r \\ u_r \\ p_r \end{array} \right),
U = \left( \begin{array}{ccc} d \\ u \\ p \end{array} \right) = riem(U_l, U_r)
\end{equation}

В формуле (\ref{eq:riemann}) через $d_l$, $u_l$, $p_l$ обозначены плотность, скорость и давление газа слева от разрыва (они объединены в структуру  $U_l$ -- состояние газа слева от разрыва).
Аналогично через $d_r$, $u_r$, $p_r$ обозначены плотность, скорость и давление газа справа от разрыва, объединенные в состояние газа $U_r$.
Переменными $d$, $u$, $p$ обозначены плотность, скорость и давление газа, полученные в результате решения задачи Римана.

Библиотека NUMERICA реализована на языке программирования FORTRAN, поэтому векторизация данного кода с использованием функций-интринсиков напрямую невозможна, поэтому использовалась портированная на язык программирования C версия кода.

В процессе счета с помощью численных методов, базирующихся на римановском решателе, выполняется множество вызовов функции \texttt{riemann} с различными наборами входных данных (на каждой итерации счета выполняется один вызов для каждой грани каждой ячейки расчетной сетки).
Так как функция riemann является чистой, то вызовы для разных наборов входных данных (\texttt{dl}, \texttt{ul}, \texttt{pl}, \texttt{dr}, \texttt{ur}, \texttt{pr}) являются независимыми и возникает желание объединения вызовов с целью эффективного задействования векторных (поэлементных) инструкций.
В качестве такого объединенного вызова будем рассматривать функцию, в которую вместо атомарных данных типа \texttt{float} будут подаваться соответствующие векторы, содержащие по $WIDTH$ элементов.

\begin{equation}\label{eq:riemann_16}
\overline{U_l} = \left( \begin{array}{ccc} \overline{d_l} \\ \overline{u_l} \\ \overline{p_l} \end{array} \right),
\overline{U_r} = \left( \begin{array}{ccc} \overline{d_r} \\ \overline{u_r} \\ \overline{p_r} \end{array} \right),
\overline{U} = \left( \begin{array}{ccc} \overline{d} \\ \overline{u} \\ \overline{p} \end{array} \right) = riem(\overline{U_l}, \overline{U_r})
\end{equation}

В формуле (\ref{eq:riemann_16}) все переменные $\overline{d_l}$, $\overline{u_l}$, $\overline{p_l}$, $\overline{d_r}$, $\overline{u_r}$, $\overline{p_r}$, $\overline{d}$, $\overline{u}$, $\overline{p}$ являются векторами длины 16.
Например, вектор $\overline{d}$ содержит 16 значений плотности газа, полученных при решении 16 задач Римана, объединенных в один вызов.
Аналогично с другими переменными.

При этом с векторными данными можно производить те же действия, что и с базовыми типами -- выполнять вычисления, передавать в функции, возвращать в качестве результата.

Римановский решатель обладает сложной программной структурой и состоит из нескольких функций, каждая из которых может быть векторизована с использованием специальных подходов.
Однако мы рассмотрим только одну из этих функций $starpu$, обладающую наиболее интересной особенностью -- при объединении нескольких ее вызовов в одну функцию она порождает плоский цикл, телом которого является цикл с неизвестным количеством итераций.

\begin{lstlisting}[caption={Оригинальная версия функции \texttt{starpu}.},label={lst:prac_riemann_starpu_orig}]
void starpu(float dl, float ul, float pl, float cl,
            float dr, float ur, float pr, float cr,
            float &p, float &u)
{
    const int nriter = 20;
    const float tolpre = 1.0e-6;
    float change, fl, fld, fr, frd, pold, pstart, udiff;

    guessp(dl, ul, pl, cl, dr, ur, pr, cr, pstart);
    pold = pstart;
    udiff = ur - ul;

    int i = 1;

    for ( ; i <= nriter; i++)
    {
        prefun(fl, fld, pold, dl, pl, cl);
        prefun(fr, frd, pold, dr, pr, cr);
        p = pold - (fl + fr + udiff) / (fld + frd);
        change = 2.0 * abs((p - pold) / (p + pold));

        if (change <= tolpre)
        {
            break;
        }

        if (p < 0.0)
        {
            p = tolpre;
        }

        pold = p;
    }

    if (i > nriter)
    {
        cout << "divergence in Newton-Raphson iteration" << endl;
        exit(1);
    }

    u = 0.5 * (ul + ur + fr - fl);
}
\end{lstlisting}

\ \\

Цикл, расположенный в данной функции, кроме неизвестного количества итераций содержит также условные переходы (\texttt{if, break}) и вызовы функций prefun, что также усложняет его векторизацию.
Перед выполнением векторизации данный цикл необходимо преобразовать в предикатную форму, в которой тело не должно содержать операций перехода.
Все инструкции цикла выполняются под своими предикатами, а выполнение цикла прерывается при условии обнуления всех предикатов.
При этом стоит заметить, что вызовы функций prefun также должны обладать соответствующими предикатами.
После преобразования тела цикла в предикатную форму, он может быть векторизован, после чего предикаты инструкций заменятся на векторные регистры-маски (именно в этом месте появляется дополнительный параметр векторизованной функции \texttt{prefun} в виде маски).
Результат векторизации функции \texttt{starpu} представлен на листинге ниже.

\begin{lstlisting}[caption={Векторизованная версия функции \texttt{starpu}.},label={lst:prac_riemann_starpu_vec}]
void starpu_16(__m512 dl, __m512 ul, __m512 pl, __m512 cl,
               __m512 dr, __m512 ur, __m512 pr, __m512 cr,
               __m512 *p, __m512 *u)
{
    __m512 two, tolpre, tolpre2, udiff, pold, fl, fld, fr, frd, change;
    __mmask16 cond_break, cond_neg, m;
    const int nriter = 20;
    int iter = 1;

    two = SET1(2.0);
    tolpre = SET1(1.0e-6);
    tolpre2 = SET1(5.0e-7);
    udiff = SUB(ur, ul);

    guessp_16(dl, ul, pl, cl, dr, ur, pr, cr, &pold);

    // Start with full mask.
    m = 0xFFFF;

    for (; (iter <= nriter) && (m != 0x0); iter++)
    {
        prefun_16(&fl, &fld, pold, dl, pl, cl, m);
        prefun_16(&fr, &frd, pold, dr, pr, cr, m);
        *p = _mm512_mask_sub_ps(*p, m, pold,
                                _mm512_mask_div_ps(z, m,
                                                   ADD(ADD(fl, fr), udiff),
                                                   ADD(fld, frd)));
        change = ABS(_mm512_mask_div_ps(z, m, SUB(*p, pold),
                                        ADD(*p, pold)));
        cond_break = _mm512_mask_cmp_ps_mask(m, change,
                                             tolpre2, _MM_CMPINT_LE);
        m &= ~cond_break;
        cond_neg = _mm512_mask_cmp_ps_mask(m, *p, z, _MM_CMPINT_LT);
        *p = _mm512_mask_mov_ps(*p, cond_neg, tolpre);
        pold = _mm512_mask_mov_ps(pold, m, *p);
    }

    // Check for divergence.
    if (iter > nriter)
    {
        cout << "divergence in Newton-Raphson iteration" << endl;
        exit(1);
    }

    *u = MUL(SET1(0.5), ADD(ADD(ul, ur), SUB(fr, fl)));
}
\end{lstlisting}

\ \\

На листинге видна изначальная инициализация полной маски выполнения векторизованных итераций цикла. По мере работы цикла маска истощается, и при полном ее обнулении цикл завершает работу.

Стоит отметить, что векторизация цикла с неизвестным числом итераций может быть довольно опасной, так как количество итераций векторизованного цикла равно максимуму из количеств итераций циклов из 16 объединяемых вызовов оригинальной невекторизованной функции.
При большой разнице в количестве итераций оригинального кода возникает падение эффективности.

В результате применения векторизации для всех функций римановского решателя удалось достичь суммарного ускорения решателя в 7 раз.
%Можно также отметить работы \cite{BaderSWEVect,FerreiraSWEVect} по данному направлению.

\subsection{Vectorization of cells classification in the implementation of the immersed boundary method}

При численном решении задач газовой динамики часто приходится сталкиваться с телами, обладающими сложной геометрией.
Для таких тел построение согласованной расчетной сетки может быть крайне трудозатратной задачей.
Альтернативой в данном случае является использование метода погруженной границы.
Данный метод позволяет использовать для расчетов несогласованную сетку и даже простую декартову сетку, что сильно упрощает выполнение расчетов.
В рамках реализации метода погруженной границы требуется решать частную задачу определения пересечения треугольника и прямоугольного параллелепипеда в пространстве для большого количества данных геометрических примитивов.

Пусть треугольник задан тремя точками: $A(x_A, y_A, z_A)$, $B(x_B, y_B, z_B)$, $C(x_C, y_C, z_C)$.
Тогда координаты любой точки $P(x, y, z)$, находящейся внутри треугольника, можно представить следующим образом:

\begin{equation}
\begin{cases}
x = x_A + (x_B - x_A)\alpha + (x_C - x_A)\beta \\
y = y_A + (y_B - y_A)\alpha + (y_C - y_A)\beta \\
z = z_A + (z_B - z_A)\alpha + (z_C - z_A)\beta
\end{cases}
\end{equation}

где $\alpha \ge 0$, $\beta \ge 0$, $\alpha + \beta \ge 1$.

Геометрическим местом точек прямоугольного параллелепипеда является множество точек $P(x, y, z)$, координаты которых удовлетворяют следующей системе неравенств:

\begin{equation}
\begin{cases}
x_l \le x \le x_h \\
y_l \le y \le y_h \\
z_l \le z \le z_h
\end{cases}
\end{equation}

Для установления факта пересечения треугольника и прямоугольного параллелепипеда нужно определить, имеет ли решение приведенная ниже система неравенств относительно $\alpha$ и $\beta$:

\begin{equation}
\begin{cases}
x_l \le x_A + (x_B - x_A)\alpha + (x_C - x_A)\beta \le x_h \\
y_l \le y_A + (y_B - y_A)\alpha + (y_C - y_A)\beta \le y_h \\
z_l \le z_A + (z_B - z_A)\alpha + (z_C - z_A)\beta \le z_h \\
\alpha \ge 0 \\
\beta \ge 0 \\
\alpha + \beta \le 1
\end{cases}
\end{equation}

Для подобных систем неравенств существует много различных способов решения.
В нашем случае система довольно простая, содержит две переменные, и к ней может быть применен метод свертывания конечных систем линейных неравенств.

Для решения методом свертывания систему неравенств преобразуем так, чтобы она содержала неравенства только вида $k_{\alpha}\alpha + k_{\beta}\beta + k \le 0$.
После этого выполняется один шаг свертывания (или деформации системы) и она превращается в систему неравенств относительно одной переменной, проверка разрешимости которой не представляет труда.
Будем выполнять деформацию системы с целью исключить из нее переменную $\alpha$.
Для этого составим новую систему, в которую войдут все неравенства исходной системы вида $k_{\beta}\beta + k \le 0$, а каждая пара неравенств

\begin{equation}
\begin{cases}
k_{\alpha}^1 \alpha + k_{\beta}^1 + k^1 \le 0 \\
k_{\alpha}^2 \alpha + k_{\beta}^2 + k^2 \le 0 \\
\end{cases}
\end{equation}

где $k_{\alpha}^1 < 0$, а $k_{\alpha}^2 > 0$ войдет в деформированную систему в виде

\begin{equation}
(k_{\beta}^1 k_{\alpha}^2 - k_{\beta}^2 k_{\alpha}^1)\beta + (k^1 k_{\alpha}^2 - k^2 k_{\alpha}^1) \le 0
\end{equation}

Так как исходная система содержит 9 уравнений, по крайней мере одно из которых имеет нулевой коэффициент при переменной $\alpha$, а из оставшихся восьми половина коэффициентов при переменной $\alpha$ неотрицательны, а половина неположительны, то деформированная система будет содержать не более 17 уравнений.

Рассмотрим реализацию функции \\
$tri\_box\_intersect(xa, ya, za, xb, yb, zb, xc, yc, zc, xl, xh, yl, yh, zl, zh) \rightarrow int$, анализирующую наличие пересечения треугольника и прямоугольного параллелепипеда.
Функция возвращает 1, если пересечение есть, и 0, если пересечения нет.
Логика работы функции следующая.
Сначала коэффициенты разрешаемой системы неравенств заносятся в двумерный массив коэффициентов $b[bec][3]$, где $bec$ (basic equations count) -- количество исходных неравенств системы (в нашем случае 9).
Затем выполняется один шаг свертывания системы с одновременным поиском множества решения для переменной $\beta$.
Перед началом свертывания множество допустимых значений для переменной $\beta$ принимается в виде отрезка $[0, 1]$ ($lo = 0$, $hi = 1$).
По мере свертывания системы неравенств происходит сокращение данного множеств решений.
Если на каком-то  этапе свертывания множество решений обращается в пустое ($lo > hi$), то функция заканчивает работу и возвращает 0.
Если после выполнения всех действий свертывания множество решений осталось ненулевым, то это означает наличие пересечения, и функция возвращает 1.
Реализация свертывания системы уравнений представлена на листинге ниже:

\begin{lstlisting}[caption={Исходная реализация свертывания системы линейных неравенств для определения пересечения треугольника и прямоугольного параллелепипеда.},label={lst:prac_intersect_1}]
for (i = 0; i < bec; i++)
{
    bi0 = b[i][0];

    if (bi0 == 0.0)
    {
        if (!upgrade(b[i][1], b[i][2], &lo, &hi))
        {
            return 0;
        }
    }
    else
    {
        for (j = i + 1; j < bec; j++)
        {
            if (bi0 * b[j][0] < 0.0)
            {
                f0 = bi0 * b[j][1] - b[j][0] * b[i][1];
                f1 = bi0 * b[j][2] - b[j][0] * b[i][2];

                if (bi0 < 0.0)
                {
                    f0 = -f0;
                    f1 = -f1;
                }

                if (!upgrade(f0, f1, &lo, &hi))
                {
                    return 0;
                }
            }
        }
    }
}

return 1;
\end{lstlisting}

\ \\
 
Функция $upgrade$, которая вызывается из кода, предназначена для обновления текущего множества допустимых значений для переменной $\beta$ с учетом нового полученного ограничения вида $k_{\beta}\beta + k \le 0$, коэффициенты которого передаются в первом и втором параметрах.
Текущее множество решений является отрезком с границами, хранящимися в переменных $lo$ и $hi$, и в зависимости от знака коэффициента $k_{\beta}$ одна из этих границ внутри вызова функции $upgrade$ может измениться (граница $lo$ может увеличиться, либо граница $hi$ может уменьшиться).
Если после обновления множества решений оно оказывается пустым (нижняя граница становится больше верхней), то функция $upgrade$ возвращает 0, в противном случае она возвращает 1.

После рассмотрения реализации функции $tri\_box\_intersect$ можно перейти к векторизации вычислений.
Для анализа пересечения двух сеток необходимо вызывать функцию $tri\_box\_intersect$ многократно с разными наборами входных параметров.
Для оптимизации этого процесса реализуем функцию $tri\_box\_intersect\_w$, объединяющую внутри себя обработку $WIDTH$ вызовов функции $tri\_box\_intersect$.

Ниже представлена реализация функции $tri\_box\_intersect\_w$ в первом приближении.

\begin{lstlisting}[caption={Исходная реализация функции, объединяющей $WIDTH$ вызовов функции $tri\_box\_intersect$.},label={lst:prac_intersect_w}]
void tri_box_intersect_w(float *xa, float *ya, float *za,
                         float *xb, float *yb, float *zb,
                         float *xc, float *yc, float *zc,
                         float *xl, float *xh,
                         float *yl, float *yh,
                         float *zl, float *zh,
                         int *r)
{
    for (int w = 0; w < WIDTH; w++)
    {
        r[w] = tri_box_intersect(xa[w], ya[w], za[w],
                                 xb[w], yb[w], zb[w],
                                 xc[w], yc[w], zc[w],
                                 xl[w], xh[w],
                                 yl[w], yh[w],
                                 zl[w], zh[w]);
    }
}
\end{lstlisting}

\

Конечно в реальной задаче требуется обрабатывать миллионы вызовов, однако они могут быть разбиты на группы по $WIDTH$ и обработаны с помощью функции $tri\_box\_intersect\_w$, поэтому остановимся подробнее на векторизации данной функции. 
 
Для векторизации функции $tri\_box\_intersect\_w$ следует выполнить подстановку тела функции $tri\_box\_intersect$ в место ее вызова.
После выполнения данного преобразования получаем плоский цикл, телом которого является гнездо циклов со сложным управлением.
Наличие большого количества условных операторов в исходном коде порождает множество инструкций под нулевыми предикатами в результирующем коде в случае слияния кода, что негативно сказывается на производительности.
Для уменьшения количества условных операторов, можно использовать математические тождества, заменяющие условные конструкции на команды, имеющие векторные аналоги в наборе инструкций AVX-512.
Например в рассматриваемом коде вычисление значений $f0$ и $f1$ с учетом условия $b[i][0] * b[j][0] < 0$ может быть заменено на следующее:

\begin{lstlisting}[caption={Применение тождеств для использования векторных инструкций.},label={lst:prac_intersect_16_2}]
f0 = fabs(bi0) * b[j][1]
     + fabs(b[j][0]) * b[i][1]
f1 = fabs(bi0) * b[j][2]
     + fabs(b[j][0]) * b[i][2]
\end{lstlisting}

\

Похожие трудности вызывает внешнее условие \texttt{if} на листинге \ref{lst:prac_intersect_1}.
Данное условие имеет альтернативную ветку, содержащую цикл.
Слияние данных двух ветвей снижает производительность результирующего кода, поэтому в данном случае выгодно применить расщепление внешнего цикла по конструкции \texttt{if-else}.
При этом образуются два гнезда циклов, каждое из которых может быть векторизовано независимо.
Заметим, что описанное преобразование в общем смысле не является эквивалентным, так как обе ветки условия \texttt{if-else}, а значит и тела образовавшихся циклов содержат выходы из функции, выполнение расщепления цикла может изменить условие, провоцирующее выход из функции.
По этой причине компилятор не способен выполнить данное преобразование автоматически.
Однако с точки зрения результата функции данное преобразование корректно, поэтому мы его и применяем.

Отметим еще один крайне положительный момент в рассматриваемом программном контексте.
Условием выхода из вложенных циклов является достижение индуктивной переменной значения $bec$.
Данное значение является константой, а значит не зависит от номера итерации, поэтому в векторный код это условие может быть перенесено без изменений.
В случае зависимости условия выхода из цикла от номера итерации само условие должно быть также векторизовано, что может привести к потерям производительности.
Однако в рассматриваемом коде проблем векторизации циклов с нерегулярным количеством итераций нет.
На листингах ниже приведем получившийся код для функции $tri\_box\_intersect\_w$, а также его схематичную трансформацию в векторный аналог.

\begin{lstlisting}[caption={Схема программного кода перед переводом в векторную форму.},label={lst:prac_inter_pred}]
float b[bec][3][WIDTH];

<init b>;

for (int w = 0; w < WIDTH; w++) r[w] = 1;

for (int w = 0; w < WIDTH; w++)
{
    lo = 0.0;
    hi = 1.0;

    for (i = 0; i < bec; i++)
    {
        upgrade(b[i][0][w] == 0.0,
                b[i][1][w], b[i][2][w], &lo, &hi);
        if (lo > hi) break;
    }

    for (i = 0; i < bec; i++)
    {
        bi0 = b[i][0][w];
        abi0 = fabs(bi0);

        for (j = i + 1; j < bec; j++)
        {
            bj0 = b[j][0][w];
            abj0 = fabs(bj0);

            upgrade(bi0 * bj0 < 0.0,
                    abi0 * b[j][1][w] + abj0 * b[i][1][w],
                    abi0 * b[j][2][w] + abj0 * b[i][2][w],
                    &lo, &hi);
            if (lo > hi) break;
        }

        if (lo > hi) break;
    }

    if (lo > hi) r[w] = 0;
}
\end{lstlisting}

\ \\

\begin{lstlisting}[caption={Векторная форма получившегося программного кода из листинга \ref{lst:prac_inter_pred}.},label={lst:prac_inter_vec}]
__m512 b[bec][3];

<init b>;

_mm512_store_epi32(r, _mm512_set1_epi32(1));



__m512 lo = z0;
__m512 hi = z1;

for (i = 0; i < bec; i++)
{
    upgrade(_mm512_cmpeq_ps_mask(b[i][0], z0),
            b[i][1], b[i][2], &lo, &hi);
    if (!_mm512_cmplt_ps_mask(lo, hi)) break;
}

for (i = 0; i < bec; i++)
{
    bi0 = b[i][0];
    abi0 = ABS(bi0);

    for (j = i + 1; j < bec; j++)
    {
        bj0 = b[j][0];
        abj0 = ABS(bj0);

        upgrade(_mm512_cmplt_ps_mask(MUL(bi0, bj0), z0),
                FMADD(abi0, b[j][1], MUL(abj0, b[i][1])),
                FMADD(abi0, b[j][2], MUL(abj0, b[i][2])),
                &lo, &hi);
        if (!_mm512_cmplt_ps_mask(lo, hi)) break;
    }

    if (!_mm512_cmplt_ps_mask(lo, hi)) break;
}

_mm512_mask_store_epi32(r,
                        _mm512_cmplt_ps_mask(hi, lo),
                        _mm512_set1_epi32(0));
\end{lstlisting}

\ \\

Из листингов \ref{lst:prac_inter_pred} и \ref{lst:prac_inter_vec} видно, что правильно составленный предикатный код может быть довольно просто переведен в векторный аналог.
Для достижения этого были удовлетворены следующие условия.
Во-первых, удалены все ветки $else$ в условных операторах.
Во-вторых, вызов функции $upgrade$ вынесен из-под предиката.
Вместо этого в нашем случае скалярное условие вызова функции $upgrade$ трансформировалось в аргумент данной функции, и после этого код легко поддается векторизации.
В остальном все вещественные скалярные инструкции были просто заменены на векторные аналоги.

Выполненные преобразования позволили добиться ускорения функции \\
$tri\_box\_intersect\_w$ в 6.7 раз.

\section{Conclusion}

Conclusion.

\begin{acknowledgments}
The work has been done at the JSCC RAS as part of the state assignment for the topic ... The supercomputer MVS-10P, located at the JSCC RAS, was used for calculations during the research.
\end{acknowledgments}

\begin{thebibliography}{99}

\bibitem{Rybakov_Aircraft}
\refitem{article}
A.~A.~Rybakov,{\it ``Optimization of the problem of conflict detection with dangerous aircraft movement areas to execute on Intel Xeon Phi"}, Programmnye produkty i sistemy [Software \& Systems]~{\bf 30}(3), 524--528 (2017).

\bibitem{Intel_Intr}
\refitem{misc}
Intel Intrinsics Guide. \url{https://software.intel.com/sites/landingpage/IntrinsicsGuide/}. Accessed 2020.

\bibitem{Numerica}
\refitem{misc}
NUMERICA, A Library of Sources for Teaching, Research and Applications, by E.~F.~Toro. \url{https://github.com/dasikasunder/NUMERICA}. Accessed 2018.

\end{thebibliography}

\end{document}
